1. Technical Depth (Very Important)

Depth means: you can go deep on a few core areas and explain trade-offs clearly.

A. Ruby (Must-Have Depth)

Be able to explain why, not just how.

Prepare deeply:

Ruby object model

Method lookup chain (include, prepend, extend)

Singleton classes

Metaprogramming trade-offs (define_method vs method_missing)

Garbage collection (generational GC, allocation costs)

Concurrency (GIL, threads vs processes)

What Apple listens for:

Judgment

Maintainability

Performance awareness

B. Rails Internals & Architecture (Must-Have Depth)

Prepare one Rails system you know well.

Deep topics:

Request lifecycle

ActiveRecord performance (N+1, indexing, batching)

Modular monolith vs microservices

Callbacks vs service objects

Background jobs (Sidekiq)

Feature flags & safe rollouts

You should be able to:

Walk from HTTP request → DB → background job → metrics.

C. Data & Persistence (Must-Have Depth)

SQL fundamentals (joins, aggregates)

Indexing strategies

JSONB trade-offs

Data migrations & backfills

Idempotency & correctness

D. Testing (Must-Have Depth)

What to test vs what not to test

Unit vs integration vs system tests

Characterization tests for legacy systems

Testing under ambiguity

2. Technical Breadth (Important)

Breadth means: you can reason about adjacent systems and collaborate effectively.

A. Front-End (Working Knowledge)

HTML semantics

CSS basics (Flexbox)

JavaScript fundamentals

Stimulus vs Turbo

When not to use React

B. Observability & Reliability

Logging

Metrics

Alerts

Debugging production issues

Rollbacks

C. DevOps Awareness

CI/CD concepts

Feature flags

Environment configuration

Safe deploy patterns

D. Big Data Awareness

Structured vs unstructured data

Batch vs streaming

Data quality & drift

Collaboration with data scientists
